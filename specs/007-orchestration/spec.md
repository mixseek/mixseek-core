# Feature Specification: MixSeek-Core Orchestrator - マルチチーム協調実行

**Feature Branch**: `025-mixseek-core-orchestration`  
**Created**: 2025-11-04  
**Status**: Draft  
**Input**: User description: "次のオーケストレータの仕様を日本語で定義してください - 親仕様: specs/001-specs/spec.md, 関連仕様: specs/008-leader/spec.md - オーケストレータはユーザのプロンプトを受け取る - オーケストレータは各チーム(Leader Agent)に対して同じタスク(ユーザプロンプト)を実行させ、データベース(DuckDB)への記録を指示する - 各チームはラウンドコントローラによって管理され、ラウンドが終了したら終了判定を行う - すべてのチームが終了したら、オーケストレータは終了する"

## Clarifications

### Session 2025-11-04

- Q: TeamStatusのLeader Agent識別子は何を指すか → A: 関連仕様 specs/008-leader/spec.md の Key Entities「TeamConfig」および FR-008 で定義される team_id と同一とする
- Q: オーケストレータが提供する実行インタフェースは何か → A: CLI(Typer)とUI(Streamlit)の双方で実行でき、完了ステータスを提示する
- Q: ラウンド途中経過の管理はどのコンポーネントが担うか → A: 途中経過・ステータス更新はラウンドコントローラが担い、オーケストレータはチーム単位の開始と終了のみを直接制御する
- Q: オーケストレータはどのコンポーネントに対してラウンド起動を指示するか → A: 各チームのラウンドコントローラに対して開始シグナルを送信し、Leader Agentへの直接指示は行わない
- Q: オーケストレータを起動する公式CLIコマンドは何か → A: `mixseek exec \"task_prompt\"` サブコマンドを使用し、execサブコマンドがオーケストレータ起動を担当する
- Q: オーケストレータが管理するタイムアウト範囲はどこか → A: チーム単位（ラウンドコントローラ全体）のタイムアウトのみを管理し、Member Agentやモデルのタイムアウトはラウンドコントローラ内部が管理する

### Session 2025-11-05

- Q: オーケストレーション実行全体を識別するIDは何か → A: execution_id を採用し、round_history、leader_board、execution_summaryテーブルに追加する（UUID形式で生成）
- Q: ExecutionSummaryテーブルのスキーマ詳細はどうするか → A: 構造化ステータス記録方式を採用。execution_id（主キー）、status（completed/partial_failure/failed）、team_results（JSON配列: team_id/team_name/status/score/error）、total_teams、completed_at、created_atを含む
- Q: ラウンドコントローラの初期実装スコープは何か → A: 1ラウンド固定実装（round_number=1）とし、インターフェースは将来の複数ラウンド拡張を考慮した設計とする。初期実装では各チームが1ラウンド実行後に即座に終了通知を返す
- Q: DuckDB通信障害時のリトライ戦略は何か → A: 既存のAggregationStore実装と同じパターンを踏襲する。3回リトライ、指数バックオフ（1秒、2秒、4秒）、リトライ失敗時にDatabaseWriteErrorを発生させる
- Q: 並列チーム実行の並行数制御はどうするか → A: 初期実装では無制限並列実行とし、全チームを同時起動する（asyncio.gather使用）。想定チーム数が最大10と小規模なため、並行数制限は将来拡張として別フィーチャーで実装する

## User Scenarios & Testing *(mandatory)*

### User Story 1 - プロンプト受信とマルチチーム起動 (Priority: P1)

ユーザがMixSeek-Coreにプロンプトを提出すると、オーケストレータが単一のタスク定義を生成し、構成済みのすべてのチームのラウンドコントローラへ同時に配信する。各ラウンドコントローラはタスク受領を確認し、チーム内部のLeader Agent起動とDuckDBへの初期記録を行ったうえで実行を開始する。

**Why this priority**: ユーザ価値の起点であり、プロンプトを複数チームに正しく展開できなければマルチエージェント協調が成立しない。

**Independent Test**: 代表的なプロンプトを投入し、全チームにタスクが配信され、DuckDBにチーム開始レコードが登録されることを検証することで単独検証可能。

**Acceptance Scenarios**:

1. **Given** ユーザがサポート対象の形式でプロンプトを送信する、**When** オーケストレータが受信する、**Then** すべての有効なチームのラウンドコントローラに同一タスク定義が配信される
2. **Given** ラウンドコントローラがタスクを受領する、**When** オーケストレータが開始指示を送る、**Then** 各ラウンドコントローラはDuckDBに受領タイムスタンプと初期状態を記録し、チーム内部のLeader Agentを起動する
3. **Given** ラウンドコントローラが初期記録を完了する、**When** オーケストレータが起動完了を確認する、**Then** ユーザは実行開始状況を追跡できる
4. **Given** 利用者がCLIから`mixseek exec \"task_prompt\"`を実行する、**When** コマンドが受理される、**Then** オーケストレータが上記フローを起動し、CLI上に着手ステータスが表示される

---

### User Story 2 - ラウンド進行管理と終了判定 (Priority: P2) *(Future Enhancement)*

**注意**: 本ユーザストーリーは将来拡張として位置づけられ、初期実装（本フィーチャー）では対象外です。初期実装では各チームが1ラウンド固定で実行され、ラウンドコントローラは1ラウンド完了後に即座に終了通知を返します。

チームごとに割り当てられたラウンドコントローラが、複数ラウンドの開始・終了・フィードバック統合を管理する。オーケストレータは各ラウンドの状態を収集し、終了条件が満たされたタイミングでラウンドコントローラに終了評価を指示し、結果をDuckDBに残す。

**Why this priority**: TUMIX由来の反復プロセスを正しく制御しないと品質の高いSubmissionが得られず、親仕様の価値命題を満たせない。

**Independent Test**: 複数ラウンドを必要とするタスクを実行し、ラウンドコントローラが途中経過を管理してオーケストレータへ開始・終了通知を返し、各ラウンドが正しく遷移するか確認することで単独検証可能。

**Acceptance Scenarios**:

1. **Given** ラウンドコントローラが実行中である、**When** ラウンドの終了条件が成立する、**Then** オーケストレータは該当チームのラウンドコントローラへ終了判定と記録指示を送る
2. **Given** 終了判定が完了する、**When** ラウンドコントローラが結果とフィードバックを返す、**Then** オーケストレータはDuckDBにラウンド完了レコードを確定する
3. **Given** 途中ラウンドで評価が未完了となる、**When** ラウンドコントローラが遅延ステータスを報告する、**Then** オーケストレータは再評価または中断待機を指示し、その結果を記録する

---

### User Story 3 - 実行全体の完了集約と終了通知 (Priority: P3)

すべてのチームがラウンドを完了した時点で、オーケストレータは最終的な実行状態を集約し、DuckDBに最終サマリーを保存するとともに、外部利用者（ユーザ・管理者）へ完了通知とアクセス手段を提供する。

**Why this priority**: ユーザは最終結果と監査証跡を受け取ることで体験を完結でき、ビジネス価値が成立する。

**Independent Test**: 複数チームが異なる終了タイミングで完了するシナリオを用意し、全完了後にサマリーが保存・通知されることを確認すれば単独検証が可能。

**Acceptance Scenarios**:

1. **Given** 一部のチームが完了し他が未完了である、**When** オーケストレータが状態を監視する、**Then** 未完了チームは待機状態のまま完了チームの記録が保持される
2. **Given** 最後のチームが終了判定を返す、**When** オーケストレータが全チームの完了を確認する、**Then** 最終サマリーとチーム別結果がDuckDBにまとめて保存される
3. **Given** 最終サマリーが保存済みである、**When** ユーザが結果取得を要求する、**Then** オーケストレータは完了通知とアクセス情報を提供する
4. **Given** CLIまたはUIから実行が開始されている、**When** 全チームが完了する、**Then** それぞれのインタフェース上で完了ステータスと結果参照手段が提示される

---

### Edge Cases

- チームのいずれかがDuckDBへの記録に失敗した場合、オーケストレータはFR-008およびFR-006に従い書き込みキューへ退避し、定義済みリトライポリシーで再送し、それでも失敗する場合はチームを隔離して監査ログに記録する
- ラウンドコントローラが終了判定を返さないままタイムアウトした場合、オーケストレータはタイムアウトを検出して再評価リクエストを一度送信し、再試行が失敗した場合はラウンドを強制終了してステータスを「判定不能」として記録する
- 実行途中でユーザがキャンセル要求を出した場合、オーケストレータは全チームとラウンドコントローラへ即時停止シグナルを送出し、進行中ラウンドを中断して部分的な結果とキャンセル理由をDuckDBに記録する
- 複数のチームが同じタイムスタンプで完了した場合、オーケストレータはソートルール（完了順＋チーム優先度）で決定順を確定し、ExecutionSummaryに決定過程を残して整合性を維持する
- 並列実行中にDuckDBが一時的に利用不能になった場合、オーケストレータはメモリ内バッファにイベントを保持し、接続復旧を監視して再送を行い、それでも復旧しない場合はフェイルセーフとして実行を停止し利用者へ復旧待機メッセージを提示する

## Requirements *(mandatory)*

### Functional Requirements

- **FR-001**: オーケストレータはユーザプロンプトを受信した時点でexecution_id（UUID形式）を生成し、単一のタスク定義に正規化して親仕様で定義されたチーム設定に基づき各チームのラウンドコントローラへ同時配信しなければならない。初期実装では全チームを並列実行し（asyncio.gather使用）、並行数制限は行わない
- **FR-002**: 各チームへの配信後、オーケストレータはDuckDBにexecution_id、チーム識別子、配信時刻、タスクメタデータを即時記録しなければならない。既存のround_historyおよびleader_boardテーブルにexecution_idカラムを追加して同一実行に属するレコードを識別可能にする
- **FR-003**: オーケストレータはラウンドコントローラを経由してラウンドの終了通知および最終評価結果を受け取り、ラウンドごとの記録・管理はラウンドコントローラに委譲し、オーケストレータは最終結果の確認と集約に集中しなければならない。初期実装では各チームは1ラウンド固定（round_number=1）で実行され、ラウンドコントローラは1ラウンド完了後に即座に終了通知を返す
- **FR-004**: ラウンド終了手続きはラウンドコントローラの責務とし、オーケストレータは終了通知を受領して最終結果集約に進まなければならない。初期実装では終了条件判定は不要で、1ラウンド完了時点で自動的に終了する
- **FR-005**: すべてのチームが完了したことを検出した時点で、オーケストレータはexecution_idを主キーとする全体サマリーをexecution_summaryテーブルへ保存するとともに、外部利用者へ完了通知を提供しなければならない。statusフィールドは全チーム成功時に"completed"、一部チーム失格時に"partial_failure"、全チーム失敗時に"failed"と設定する。team_resultsには各チームのteam_id、team_name、status（success/failed/timeout）、score（成功時のみ）、error（失敗時のみ）をJSON配列で記録する
- **FR-006**: チームのいずれかが進行不能（タイムアウト、エラー）となった場合、オーケストレータは同チームを即座に失格とし、再試行は行わず、失格理由とステータスを記録しなければならない（親仕様の失格処理ポリシーに従う）。タイムアウト管理の対象はラウンドコントローラ全体に限定され、個々のMember Agentやモデルのタイムアウト管理はラウンドコントローラ内部の責務とする
- **FR-007**: オーケストレータは実行中にチーム単位の状態を問い合わせできる監視インターフェースを提供し、ラウンドコントローラから取得したステータスをUI層へ渡して可視化させなければならない（可視化処理自体はUIの責務とする）
- **FR-008**: オーケストレータはDuckDBとの通信障害時に既存のAggregationStore実装と同じリトライ戦略を使用しなければならない。具体的には、3回リトライ、指数バックオフ（1秒、2秒、4秒）を実施し、リトライ失敗時にDatabaseWriteErrorを発生させて呼び出し元に伝播する。インメモリキューは使用せず、直接書き込み＋リトライ方式を採用する
- **FR-009**: オーケストレータは実行ログとメタデータを親仕様で定義された監査保持期間中、完全性を損なわず参照可能な状態で保持しなければならない
- **FR-010**: オーケストレータはCLI（Typer）およびUI（Streamlit）の両インタフェースを提供し、CLIでは`mixseek exec \"task_prompt\"`サブコマンドからタスク実行を開始でき、完了時にそれぞれのインタフェース上で明示的な完了ステータスと結果リンクを表示しなければならない

### Key Entities *(include if feature involves data)*

- **OrchestratorTask**: ユーザプロンプトから生成されたタスク定義。execution_id（UUID形式、オーケストレーション実行全体の一意識別子）、関連するチーム一覧、開始時刻、優先度などのメタデータを保持する
- **TeamStatus**: 特定チームの実行状態。execution_id（所属する実行の識別子）、team_id（Leader Agent識別子、関連仕様 specs/008-leader/spec.md の Key Entities「TeamConfig」および FR-008 参照）、現在のラウンド番号、進行状況、エラー状態、通知先を含む
- **ExecutionSummary**: 全チームの完了後に生成される最終集約情報。execution_id（主キー、UUID）、status（completed/partial_failure/failed）、team_results（JSON配列: [{team_id, team_name, status, score, error}]）、total_teams（チーム総数）、completed_at（完了時刻）、created_at（作成時刻）を含む。DuckDBのexecution_summaryテーブルに永続化され、監査トレース用の参照点となる

## Success Criteria *(mandatory)*

### Measurable Outcomes

- **SC-001**: 対象プロンプトの95%以上で、オーケストレータが受信後10秒以内に全チームへタスク配信完了通知を返せる
- **SC-002**: 実行したラウンドの100%で、終了後60秒以内にDuckDBから完全なラウンド記録を参照できる
- **SC-003**: 複数チームが並列で完了するケースにおいて、完了検知から2分以内に最終サマリーが保存され、ユーザが結果にアクセスできる
- **SC-004**: 実行監視を行う利用者の少なくとも85%が進行状況の可視化によりタスクの状態を把握できたと回答する（サポート調査）
- **SC-005**: CLIとUIの双方で開始したタスクの100%が、完了検知から30秒以内に各インタフェース上で完了ステータスと結果参照リンクを表示する

## Assumptions

- DuckDBのスキーマと書き込みインターフェースは親仕様（specs/001-specs/spec.md の FR-002, FR-003, FR-009）および関連仕様（specs/008-leader/spec.md の FR-007, FR-008, Key Entities「RoundHistory」）で既に定義されている前提で運用する。本仕様でexecution_idカラムを追加する
- チーム構成（TOMLベースの`TeamConfig`。親仕様 specs/001-specs/spec.md の FR-014 および関連仕様 specs/008-leader/spec.md の Configuration Example 参照）とラウンドコントローラの個別パラメータ（親仕様 FR-007、Clarifications「Round Controllerの終了判定」参照）は既に設定済みであり、本仕様では変更しない
- 完了通知の配信手段（API、CLI、通知チャネル）は親仕様のオーケストレーションレイヤーと整合する既存手段を利用する
- リトライポリシーやタイムアウト閾値の具体値は運用チームが設定し、本仕様では閾値の存在のみを要求する
- 初期実装では各チームは1ラウンド固定（round_number=1）で実行される。複数ラウンド対応（User Story 2）は将来拡張として別フィーチャーで実装する。インターフェース設計は複数ラウンド拡張を考慮した設計とする
- 初期実装では全チーム（1〜10チーム想定）を並列実行し、並行数制限は行わない。リソース管理（メモリ、モデルAPI制限）は外部（OS、モデルAPI側）に委譲する。並行数制限（セマフォ等）は将来拡張として別フィーチャーで実装する
